<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>qiuqiu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=1, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
</head>

<body>


    <div class="g-gamebox" id="j-gamebox">
        <canvas id="canvas"></canvas>
    </div>


    <script src="js/zepto.min.js"></script>
    <script>


    var gamebox = $('#j-gamebox');
 
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');

    canvas.width = gamebox.width();
    canvas.height = gamebox.height();

    var launchWidth = canvas.width*0.15;



    /*障碍小球*/
    var obs = {
        r: 4,
        mass: 10,
        balls: [
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
            [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]
        ],
        pos: []
    };

    /*底部栏*/
    var btObs = {
        length: 6,
        y: canvas.height - canvas.height * 0.23,
        pos: []
    };

    btObs.width = (canvas.width - launchWidth)/btObs.length;
    for(var i=0; i<btObs.length; i++){
        btObs.pos.push({
            x: btObs.width* i,
            x2: btObs.width* (i+1)
        });
    };


    obs.intervalx = (canvas.width - launchWidth)/(obs.balls[0].length + 1);
    obs.offt = canvas.height * 0.26;
    obs.intervaly = canvas.height * 0.14;


    /*  1: -18,-5
        2: -15,y:-8
        3: x-15,y:-8
        4: x-8,y:10
        5: x-15,y:8
    */
    var ball = {
        speed: 1,
        speedX: -15,
        speedY: -8,
        x: canvas.width - 100,
        y: 20,
        r: canvas.width*0.03,
        mass: 20
    };
    
    var first = 0;
    var xzz,yzz;

    function App(){
        this.init();
    }
    App.prototype = {
        init: function(){
            var _this = this;
            this.drawApp(ball.x,ball.y);
            first = 1;
            setTimeout(function(){
                _this.move();
            },1000);
        },

        /*绘制障碍*/
        drawObs: function(){
            var _this = this,x,y;
            obs.balls.forEach(function(oys,yIndex){
                oys.forEach(function(ox,xIndex){
                    if(ox){
                        x = obs.intervalx * (xIndex + 1);
                        y = obs.offt + obs.intervaly * yIndex;
                        _this.drawBall(x , y,obs.r,'#688db7');
                        !first && obs.pos.push({x:x, y:y});
                    }
                });
            });
        },
        /*绘制球*/
        drawBall: function(x,y,r,color){
            context.beginPath();
            context.fillStyle = color || '#333';
            context.arc(x,y,r,0,2*Math.PI);
            context.fill();
            context.closePath();
        },

        drawLine: function(){
            for(var i=0; i<btObs.pos.length; i++){
                context.beginPath();
                context.fillStyle = 'green';
                context.rect(btObs.pos[i].x2,btObs.y, 2, canvas.height - btObs.y);
                context.fill();
                context.closePath();
            }
        },

        /*绘制整个画布*/
        drawApp: function(){
            context.clearRect(0,0,canvas.width,canvas.height);
            this.drawObs();
            this.drawLine();
            this.drawBall(ball.x,ball.y,ball.r,'#17d6e2');
        },

        /*根据角度计算X轴和Y轴每次要移动的量*/
        updataBall: function(){
            var radians = ball.radio*Math.PI/180;
            xzz = Math.cos(radians)*ball.speed;
            yzz = Math.sin(radians)*ball.speed;
        },

        move: function(){
            var _this = this;

            /*move*/
            //setTimeout(function fn(){
            window.requestAnimationFrame(function fn(){
                _this.collide();

                ball.speedY =  ball.speedY + 3;
                ball.x = ball.x + ball.speedX;
                ball.y = ball.y + ball.speedY;

                _this.collideBt();
                

                /*x边界*/
                if( ball.x + ball.r > canvas.width - launchWidth){
                    ball.speedX *= -0.95;
                    ball.speedY *= 0.95;
                    ball.x = canvas.width - ball.r - launchWidth;
                }else if(ball.x - ball.r < 0){
                    ball.speedX *= -0.95;
                    ball.speedY *= 0.95;
                    ball.x = 0 + ball.r;
                };

                /*y边界*/
                if( ball.y + ball.r > canvas.height ){
                    ball.speedY *= -0.95;
                    ball.speedX *= 0.95;
                    ball.y = canvas.height - ball.r; 
                }else if(ball.y - ball.r < 0){
                    ball.speedY *= -0.95;
                    ball.speedX *= 0.95;
                    ball.y = ball.r;
                };

                if(Math.abs(ball.speedX)<1.5) ball.speedX=0;
                if(Math.abs(ball.speedY)<1.5) ball.speedY=0;

                if(ball.speedX == 0 && ball.speedY == 0 && ball.y + ball.r >= canvas.height){
                    console.log('over');
                    ball.y = canvas.height - ball.r;
                    return;
                }else{
                   _this.drawApp();
                }
                
                //setTimeout(fn,50);
                window.requestAnimationFrame(fn);
            },50);
        },
        /*判断两球是否碰撞*/
        hitTestCircle: function(obsBall){
            var retval = false;
            var dx = ball.x - obsBall.x;
            var dy = ball.y - obsBall.y;
            var distance = dx*dx + dy*dy;
            if(distance <= (ball.r + obs.r) * (ball.r + obs.r) ){
                retval = true;
            }
            return retval;
        },

        /*循环遍历每个碰撞点*/
        collide: function(){
            for(var i=0; i<obs.pos.length; i++){
                if(this.hitTestCircle(obs.pos[i])){
                    this.collideBalls(obs.pos[i]);
                    //debugger;
                    break;
                }
            }
        },

        collideBalls: function(obsBall){
            var dx = ball.x - obsBall.x;
            var dy = ball.y - obsBall.y;
            var R = ball.r + obs.r;

            var lv = Math.sqrt(dx*dx + dy+dy);
            var collisionAngle = Math.atan2(dy,dx);

            if( lv < R ){
                ball.x = Math.ceil(ball.x + Math.cos(collisionAngle) * ( R - lv ));
                ball.y = Math.ceil(ball.y + Math.sin(collisionAngle) * ( R - lv ));
                this.drawApp();
            }
            ball.speedX *= -1;
        },

        hitTextCircleBt: function(obsLine){
            var retval = false;

            var x1 = obsLine.x + 5;
            var x2 = obsLine.x + btObs.width;
            var y = btObs.y;

            if( ball.y + ball.r > y ){
                if( ball.x - ball.r < x1 &&  ball.x + ball.r > x1 ){
                    ball.x = x1 + ball.r + 3;
                    retval = true;
                }else if(ball.x + ball.r > x2 && ball.x - ball.r  < x2){
                    ball.x = x2 - ball.r - 3;
                    retval = true;
                }
            }
            return retval;
        },

        collideBt: function(){
            for(var i=0; i<btObs.pos.length; i++){
                if(this.hitTextCircleBt(btObs.pos[i]) ){
                    ball.speedX *= -0.9;
                    break;
                }
            }
        }
    }

  
        new App();
    

    

    </script>
</body>

</html>
